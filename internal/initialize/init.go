package initialize

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"text/template"
)

// Options contains configuration for initialization
type Options struct {
	// ProjectID is the Google Cloud project ID
	ProjectID string
	// StateBackend specifies the state backend to use (e.g. "gcs")
	StateBackend string
	// StateBucket is the bucket name for the state backend
	StateBucket string
	// OutputDir is the directory to create the IaC repo
	OutputDir string
	// RepoName is the name of the repository
	RepoName string
	// GitInit whether to initialize a git repository
	GitInit bool
	// SetupGHAction whether to setup GitHub Actions workflow
	SetupGHAction bool
}

// Result contains the results of initialization
type Result struct {
	OutputDir string
	RepoInit  bool
}

// Service handles initialization of a new IaC repository
type Service struct {
	options Options
	logger  *slog.Logger
}

// NewService creates a new initialization service
func NewService(options Options, logger *slog.Logger) *Service {
	if logger == nil {
		logger = slog.New(slog.NewJSONHandler(os.Stdout, nil))
	}

	return &Service{
		options: options,
		logger:  logger,
	}
}

// Run initializes a new IaC repository
func (s *Service) Run(ctx context.Context) (*Result, error) {
	s.logger.Info("Initializing new IaC repository",
		"outputDir", s.options.OutputDir,
		"repoName", s.options.RepoName,
		"stateBackend", s.options.StateBackend)

	// Create result
	result := &Result{
		OutputDir: s.options.OutputDir,
		RepoInit:  false,
	}

	// Create directory structure
	if err := s.createDirectoryStructure(); err != nil {
		return nil, fmt.Errorf("failed to create directory structure: %w", err)
	}

	// Create basic Terraform files
	if err := s.createTerraformFiles(); err != nil {
		return nil, fmt.Errorf("failed to create Terraform files: %w", err)
	}

	// Initialize git repository if requested
	if s.options.GitInit {
		if err := s.initGitRepo(); err != nil {
			return nil, fmt.Errorf("failed to initialize git repository: %w", err)
		}
		result.RepoInit = true
	}

	// Setup GitHub Actions workflow if requested
	if s.options.SetupGHAction {
		if err := s.setupGitHubActions(); err != nil {
			return nil, fmt.Errorf("failed to setup GitHub Actions: %w", err)
		}
	}

	s.logger.Info("Repository initialized successfully",
		"outputDir", s.options.OutputDir)

	return result, nil
}

// createDirectoryStructure creates the directory structure for the IaC repository
func (s *Service) createDirectoryStructure() error {
	// Create directories
	dirs := []string{
		s.options.OutputDir,
		filepath.Join(s.options.OutputDir, "environments", "dev"),
		filepath.Join(s.options.OutputDir, "environments", "prod"),
		filepath.Join(s.options.OutputDir, "modules"),
		filepath.Join(s.options.OutputDir, ".github", "workflows"),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}

	return nil
}

// createTerraformFiles creates the basic Terraform configuration files
func (s *Service) createTerraformFiles() error {
	// Create provider.tf
	providerTmpl := `# Generated by InfraSync
terraform {
  {{if eq .StateBackend "gcs"}}
  backend "gcs" {
    bucket = "{{.StateBucket}}"
    prefix = "terraform/state"
  }
  {{end}}

  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 4.0"
    }
  }
}

provider "google" {
  project = "{{.ProjectID}}"
}
`

	// Create variables.tf
	variablesTmpl := `# Generated by InfraSync
variable "project_id" {
  description = "The Google Cloud project ID"
  type        = string
  default     = "{{.ProjectID}}"
}

variable "region" {
  description = "The default region for resources"
  type        = string
  default     = "us-central1"
}
`

	// Create main.tf
	mainTmpl := `# Generated by InfraSync
# Main Terraform configuration
`

	// Create .gitignore
	gitignoreTmpl := `# Generated by InfraSync
.terraform/
.terraform.lock.hcl
terraform.tfstate
terraform.tfstate.backup
*.tfvars
`

	// Define template data
	data := struct {
		ProjectID    string
		StateBackend string
		StateBucket  string
	}{
		ProjectID:    s.options.ProjectID,
		StateBackend: s.options.StateBackend,
		StateBucket:  s.options.StateBucket,
	}

	// Create provider.tf
	if err := s.createFileFromTemplate(filepath.Join(s.options.OutputDir, "provider.tf"), providerTmpl, data); err != nil {
		return err
	}

	// Create variables.tf
	if err := s.createFileFromTemplate(filepath.Join(s.options.OutputDir, "variables.tf"), variablesTmpl, data); err != nil {
		return err
	}

	// Create main.tf
	if err := s.createFileFromTemplate(filepath.Join(s.options.OutputDir, "main.tf"), mainTmpl, data); err != nil {
		return err
	}

	// Create .gitignore
	if err := s.createFileFromTemplate(filepath.Join(s.options.OutputDir, ".gitignore"), gitignoreTmpl, data); err != nil {
		return err
	}

	// Create README.md
	readmeTmpl := `# {{.RepoName}}

Infrastructure as Code repository managed with [InfraSync](https://github.com/priyanshujain/infrasync).

## Structure

- environments/: Environment-specific configurations
- modules/: Reusable Terraform modules
- main.tf: Main Terraform configuration

## Usage

To import existing resources:

    infrasync import --project={{.ProjectID}} --services=pubsub

To detect drift and update configurations:

    infrasync sync --project={{.ProjectID}} --state-bucket={{.StateBucket}}
`

	readmeData := struct {
		RepoName    string
		ProjectID   string
		StateBucket string
	}{
		RepoName:    s.options.RepoName,
		ProjectID:   s.options.ProjectID,
		StateBucket: s.options.StateBucket,
	}

	if err := s.createFileFromTemplate(filepath.Join(s.options.OutputDir, "README.md"), readmeTmpl, readmeData); err != nil {
		return err
	}

	return nil
}

// createFileFromTemplate creates a file from a template
func (s *Service) createFileFromTemplate(filePath, tmplStr string, data interface{}) error {
	// Create file
	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", filePath, err)
	}
	defer file.Close()

	// Parse template
	tmpl, err := template.New(filepath.Base(filePath)).Parse(tmplStr)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Execute template
	if err := tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

// initGitRepo initializes a git repository
func (s *Service) initGitRepo() error {
	// Change to output directory
	if err := os.Chdir(s.options.OutputDir); err != nil {
		return fmt.Errorf("failed to change to output directory: %w", err)
	}

	// Initialize git repository
	if err := runCommand("git", "init"); err != nil {
		return fmt.Errorf("failed to initialize git repository: %w", err)
	}

	// Add files
	if err := runCommand("git", "add", "."); err != nil {
		return fmt.Errorf("failed to add files: %w", err)
	}

	// Commit
	if err := runCommand("git", "commit", "-m", "Initial commit by InfraSync"); err != nil {
		return fmt.Errorf("failed to commit files: %w", err)
	}

	return nil
}

// setupGitHubActions creates GitHub Actions workflow files
func (s *Service) setupGitHubActions() error {
	workflowTmpl := `# Generated by InfraSync
name: InfraSync - Infrastructure Drift Detection

on:
  schedule:
    - cron: "0 0 * * *"  # Run daily at midnight
  workflow_dispatch:     # Allow manual triggering

jobs:
  sync-infrastructure:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.20'
      
      - name: Install InfraSync
        run: |
          go install github.com/priyanshujain/infrasync@latest
      
      - name: Auth to Google Cloud
        id: auth
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ "{{" }} secrets.GCP_SA_KEY {{ "}}" }}
          export_environment_variables: true
      
      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
      
      - name: Run InfraSync Sync
        run: |
          infrasync sync \
            --project=${{ "{{" }} secrets.GCP_PROJECT {{ "}}" }} \
            --services=pubsub \
            --state-bucket=${{ "{{" }} secrets.GCS_STATE_BUCKET {{ "}}" }} \
            --state-key=terraform/state \
            --output=.
        
      - name: Create PR if drift detected
        if: ${{ "{{" }} env.DRIFT_DETECTED == 'true' {{ "}}" }}
        uses: peter-evans/create-pull-request@v5
        with:
          title: "Infrastructure drift detected"
          body: |
            This PR was automatically created by the InfraSync drift detection workflow.
            
            ## Detected Changes
            
            Infrastructure drift was detected between Terraform state and actual cloud resources.
            The Terraform configuration has been updated to reflect the current state of your infrastructure.
            
            ## Review Instructions
            
            Please review the changes carefully before merging to ensure they match your intended infrastructure state.
            
            Generated with InfraSync
          branch: "infrasync-drift-${{ "{{" }} github.run_id {{ "}}" }}"
          commit-message: "Update Terraform configurations to match cloud state"
          base: main
`

	return s.createFileFromTemplate(
		filepath.Join(s.options.OutputDir, ".github", "workflows", "infrasync.yml"),
		workflowTmpl,
		nil,
	)
}

// runCommand runs a command and returns the error
func runCommand(name string, args ...string) error {
	cmd := exec.Command(name, args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}